# AI 编程规范

## 配置与简洁

1. **统一配置源**：所有系统配置统一走 settings/config 配置树；由其集中加载并常量化环境变量。禁止代码里直接读取环境变量。  
2. **KISS / YAGNI**：能不用就别加、能简单别复杂；只为明确需求设计，不预埋臆测扩展点。

## 公共模块与复用

1. **公共模块定义**：凡跨两个以上子域复用的通用能力（日志、错误码、校验、缓存、鉴权等）统一沉淀为公共模块。  
2. **消除重复（DRY）**：禁止复制粘贴公共逻辑；发现重复立即抽取到公共模块并替换调用路径。  
3. **边界与责任**：公共模块提供稳定接口与清晰文档；不向外暴露第三方库细节；模块负责人对兼容性与维护负责。  
4. **版本与兼容**：遵循语义化版本；破坏性修改必须给出弃用期与迁移指引。

## 代码质量与异常 / None

1. **异常处理**：只捕获可处理的具体异常；禁止裸 except 或仅 pass / print / log。无法恢复的异常必须向上抛，由统一层处理。  
2. **None 判断**：若上游或类型已保证非空，禁止多余 None 检查；确需防御仅放在输入 / 输出边界。  
3. **重复 / 死代码清理**：不可能分支、重复条件、被注释的大段旧代码、未使用的函数 / 变量 / 导入必须清理。

## 依赖、日志与可观测

1. **最小依赖集**：避免为一两行功能引入大库；未使用的依赖与导入定期移除。  
2. **结构化日志**：统一格式与字段（trace / user / 关键业务键）；禁止生产使用裸 print；严禁记录敏感信息, 避免重复日志。

## 架构与目录

1. **清晰分层**：app -> domain -> infra 单向依赖；第三方 SDK 统一封装在 infra/clients；业务层只依赖公共模块与领域接口。  
2. **小而专一**：函数与模块保持单一职责；拒绝“大而全 utils”；按业务域分包，公共能力沉淀到公共模块。

## 测试、文档与流程

1. **质量门禁**：静态检查（lint / 类型）、单测覆盖率、依赖与安全扫描纳入 CI；PR 小而聚焦。  
2. **文档同步**：代码变更必须同步更新文档 / 注释；删除代码需同时清理相关文档，避免误导。  
3. **每周清洁工**：例行清理（未用导入 / 依赖、冗余异常与 None 判断、重复实现、死配置、日志残留），自动生成清单或 PR。

## 决策与沟通

1. **模糊场景处理**：当规则不足以明确决策（边界条件、抽象层级、复用 vs 专用实现）时：  
    - 主动询问：向相关开发者或评审人明确预期。  
    - 提出建议：给出至少一个更简单、更一致或更具长期价值的替代方案。  
    - 记录决策：在评审 / 文档中简要说明理由，避免反复讨论。
